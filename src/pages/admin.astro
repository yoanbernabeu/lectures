---
import Layout from '../layouts/Layout.astro';
import type { Book } from '../types/book';
import { fetchGoogleBooksData } from '../utils/googleBooks';

// Vérification que nous sommes en mode dev
if (import.meta.env.PROD) {
  return Astro.redirect('/404');
}

interface BookData {
  books: Book[];
}

interface GoogleBook {
  id: string;
  volumeInfo: {
    title: string;
    authors?: string[];
    description?: string;
    imageLinks?: {
      thumbnail: string;
    };
  };
}

declare global {
  interface Window {
    handleSubmit: (event: Event, book: GoogleBook) => void;
  }
}
---

<Layout title="Administration - YoanDev Lectures">
  <div class="max-w-7xl mx-auto">
    <h1 class="text-3xl font-bold mb-8">Administration des livres</h1>
    
    <!-- Formulaire d'ajout avec recherche Google Books -->
    <div class="card bg-base-200 p-6 mb-8" x-data="{ 
      searchQuery: '',
      searchResults: [],
      selectedBook: null,
      status: 'to-read',
      async searchBooks() {
        if (!this.searchQuery.trim()) return;
        const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(this.searchQuery)}`);
        const data = await response.json();
        this.searchResults = data.items || [];
      }
    }">
      <h2 class="text-xl font-bold mb-4">Ajouter un nouveau livre</h2>
      
      <!-- Barre de recherche -->
      <div class="flex gap-4 mb-4">
        <input 
          type="text" 
          x-model="searchQuery" 
          @keyup.enter="searchBooks"
          placeholder="Rechercher un livre..." 
          class="input input-bordered flex-1"
        >
        <button @click="searchBooks" class="btn btn-primary">Rechercher</button>
      </div>

      <!-- Résultats de recherche -->
      <div x-show="searchResults.length > 0" class="mb-4">
        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          <template x-for="book in searchResults" :key="book.id">
            <div 
              class="card bg-base-300 hover:bg-base-100 cursor-pointer transition-colors"
              @click="selectedBook = book; searchResults = []"
            >
              <figure class="px-4 pt-4">
                <img 
                  :src="book.volumeInfo.imageLinks?.thumbnail" 
                  :alt="book.volumeInfo.title"
                  class="h-40 object-cover rounded"
                >
              </figure>
              <div class="card-body p-4">
                <h3 x-text="book.volumeInfo.title" class="card-title text-sm"></h3>
                <p x-text="book.volumeInfo.authors?.join(', ')" class="text-xs opacity-70"></p>
              </div>
            </div>
          </template>
        </div>
      </div>

      <!-- Formulaire d'ajout -->
      <form x-show="selectedBook" id="addBookForm" class="space-y-4" @submit.prevent="handleSubmit($event, selectedBook)">
        <input type="hidden" name="googleBooksId" x-model="selectedBook.id">
        
        <div class="flex gap-4 bg-base-300 p-4 rounded-lg">
          <img 
            :src="selectedBook?.volumeInfo?.imageLinks?.thumbnail" 
            :alt="selectedBook?.volumeInfo?.title"
            class="w-24 h-36 object-cover rounded"
          >
          <div>
            <h3 x-text="selectedBook?.volumeInfo?.title" class="font-bold"></h3>
            <p x-text="selectedBook?.volumeInfo?.authors?.join(', ')" class="text-sm opacity-70"></p>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="label">Statut</label>
            <select name="status" class="select select-bordered w-full" x-model="status">
              <option value="to-read">À lire</option>
              <option value="reading">En cours</option>
              <option value="finished">Terminé</option>
            </select>
          </div>

          <!-- Dates -->
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="label">Date de début</label>
              <input type="date" name="startDate" class="input input-bordered w-full">
            </div>
            <div>
              <label class="label">Date de fin</label>
              <input type="date" name="endDate" class="input input-bordered w-full">
            </div>
          </div>

          <!-- Progression (visible uniquement si status = reading) -->
          <div x-show="status === 'reading'">
            <label class="label">Progression (%)</label>
            <input 
              type="number" 
              name="progress" 
              min="0" 
              max="100" 
              class="input input-bordered w-full"
            >
          </div>

          <div>
            <label class="label">Note</label>
            <div class="rating rating-lg">
              {[1,2,3,4,5].map(i => (
                <input type="radio" name="rating" value={i} class="mask mask-star-2 bg-primary"/>
              ))}
            </div>
          </div>
        </div>

        <div class="flex gap-4">
          <label class="label cursor-pointer flex gap-2">
            <span class="label-text">Coup de cœur</span>
            <input type="checkbox" name="favorite" class="checkbox checkbox-primary">
          </label>

          <label class="label cursor-pointer flex gap-2">
            <span class="label-text">Abandonné</span>
            <input type="checkbox" name="abandoned" class="checkbox checkbox-error">
          </label>
        </div>

        <div>
          <label class="label">Commentaire</label>
          <textarea name="comment" class="textarea textarea-bordered w-full h-24"></textarea>
        </div>

        <div class="grid grid-cols-1 gap-4 my-4">
          <!-- Description -->
          <div>
            <label class="label">Description</label>
            <div class="prose prose-sm prose-invert mb-2">
              <div class="bg-base-300 p-4 rounded" x-html="selectedBook?.volumeInfo?.description || ''"></div>
            </div>
            <textarea 
              class="textarea textarea-bordered w-full description" 
              rows="4"
              x-model="selectedBook?.volumeInfo?.description"
            ></textarea>
          </div>
        </div>

        <button type="submit" class="btn btn-primary">Ajouter à ma bibliothèque</button>
      </form>
    </div>

    <!-- Grille des livres existants (2 colonnes max) -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6" id="bookGrid">
      Chargement des livres...
    </div>

    <button id="downloadBtn" class="btn btn-secondary mt-8">
      Télécharger le JSON modifié
    </button>
  </div>
</Layout>

<script>
  import { fetchGoogleBooksData } from '../utils/googleBooks';

  interface GoogleBook {
    id: string;
    volumeInfo: {
      title: string;
      authors?: string[];
      description?: string;
      imageLinks?: {
        thumbnail: string;
      };
    };
  }

  interface Book {
    id: string;
    googleBooksId: string;
    title?: string;
    imageUrl?: string | null;
    status: 'reading' | 'finished' | 'to-read';
    rating: number | null;
    comment: string | null;
    favorite?: boolean;
    abandoned?: boolean;
    authors?: string[];
    description?: string;
    progress?: number;
    startDate?: string;
    endDate?: string;
  }

  interface BookData {
    books: Book[];
  }

  let booksData: BookData = { books: [] };
  let nextId = 1;
  let selectedGoogleBook: GoogleBook | null = null;
  
  async function loadBooks() {
    try {
      const response = await fetch('/data/books.json');
      if(!response.ok) throw new Error("Erreur lors du chargement du fichier JSON");
      booksData = await response.json() as BookData;
      // Charger les données Google Books pour chaque livre
      await Promise.all(booksData.books.map(async (book) => {
        const googleData = await fetchGoogleBooksData(book.googleBooksId);
        book.title = googleData?.title || 'Titre inconnu';
        book.imageUrl = googleData?.imageLinks?.thumbnail || null;
        book.authors = googleData?.authors || ['Auteur inconnu'];
        book.description = googleData?.description;
      }));
      nextId = Math.max(...booksData.books.map(b => parseInt(b.id))) + 1;
      renderBooks();
    } catch (error) {
      const bookGrid = document.getElementById('bookGrid');
      if (bookGrid) {
        bookGrid.innerText = "Erreur de chargement des livres.";
      }
      console.error("Erreur : ", error);
    }
  }
  
  function renderBooks() {
    const html = booksData.books.map(book => `
      <div class="card bg-base-200 shadow-xl" data-id="${book.id}">
        <figure class="px-6 pt-6">
          <img 
            src="${book.imageUrl || '/placeholder.png'}" 
            alt="${book.title}"
            class="h-48 object-cover rounded"
          >
        </figure>
        <div class="card-body p-6">
          <div class="flex justify-between items-start">
            <h3 class="card-title text-xl">${book.title || 'Chargement...'}</h3>
            <div class="flex gap-2">
              ${book.favorite ? '<span class="badge badge-secondary">♥</span>' : ''}
              ${book.abandoned ? '<span class="badge badge-error">Abandonné</span>' : ''}
            </div>
          </div>

          <div class="grid grid-cols-1 gap-4 my-4">
            <div class="flex flex-wrap gap-4">
              <select class="select select-bordered select-sm status">
                <option value="to-read" ${book.status === 'to-read' ? 'selected' : ''}>À lire</option>
                <option value="reading" ${book.status === 'reading' ? 'selected' : ''}>En cours</option>
                <option value="finished" ${book.status === 'finished' ? 'selected' : ''}>Terminé</option>
              </select>

              <div class="flex gap-2">
                <input type="date" class="input input-bordered input-sm startDate" 
                  value="${book.startDate || ''}" placeholder="Date de début">
                <input type="date" class="input input-bordered input-sm endDate" 
                  value="${book.endDate || ''}" placeholder="Date de fin">
              </div>
            </div>

            <div class="progress-container ${book.status === 'reading' ? '' : 'hidden'}">
              <label class="label">Progression (%)</label>
              <input type="number" class="input input-bordered input-sm progress w-full" 
                min="0" max="100" value="${book.progress || 0}">
            </div>

            <div class="rating rating-sm">
              ${[1,2,3,4,5].map(i => `
                <input type="radio" class="mask mask-star-2 bg-primary rating" 
                  value="${i}" ${book.rating === i ? 'checked' : ''}>
              `).join('')}
            </div>
          </div>

          <textarea class="textarea textarea-bordered w-full comment">${book.comment || ''}</textarea>

          <div class="flex justify-between items-center mt-4">
            <div class="flex gap-4">
              <label class="label cursor-pointer">
                <span class="label-text mr-2">Coup de cœur</span>
                <input type="checkbox" class="checkbox checkbox-primary favorite" 
                  ${book.favorite ? 'checked' : ''}>
              </label>
              <label class="label cursor-pointer">
                <span class="label-text mr-2">Abandonné</span>
                <input type="checkbox" class="checkbox checkbox-error abandoned" 
                  ${book.abandoned ? 'checked' : ''}>
              </label>
            </div>

            <div class="flex gap-2">
              <button class="btn btn-sm btn-primary saveBtn">Sauvegarder</button>
              <button class="btn btn-sm btn-error deleteBtn">Supprimer</button>
            </div>
          </div>
        </div>
      </div>
    `).join('');
    
    const bookGrid = document.getElementById('bookGrid');
    if (bookGrid) {
      bookGrid.innerHTML = html;
    }
    
    document.querySelectorAll('.status').forEach(select => {
      select.addEventListener('change', function(this: HTMLSelectElement) {
        const card = this.closest('.card');
        if (card) {
          const progressContainer = card.querySelector('.progress-container');
          if (progressContainer) {
            progressContainer.classList.toggle('hidden', this.value !== 'reading');
          }
        }
      });
    });
    
    document.querySelectorAll<HTMLButtonElement>('.saveBtn').forEach(btn => {
      btn.addEventListener('click', function(this: HTMLButtonElement) {
        const card = this.closest('.card');
        if (!card) return;
        
        const id = card.getAttribute('data-id');
        const book = booksData.books.find(b => b.id === id);
        if (book) {
          const statusEl = card.querySelector<HTMLSelectElement>('.status');
          const startDateEl = card.querySelector<HTMLInputElement>('.startDate');
          const endDateEl = card.querySelector<HTMLInputElement>('.endDate');
          const progressEl = card.querySelector<HTMLInputElement>('.progress');
          const ratingEl = card.querySelector<HTMLInputElement>('.rating:checked');
          const commentEl = card.querySelector<HTMLTextAreaElement>('.comment');
          const descriptionEl = card.querySelector<HTMLTextAreaElement>('.description');
          const favoriteEl = card.querySelector<HTMLInputElement>('.favorite');
          const abandonedEl = card.querySelector<HTMLInputElement>('.abandoned');

          if (statusEl) book.status = statusEl.value as Book['status'];
          if (startDateEl) book.startDate = startDateEl.value || undefined;
          if (endDateEl) book.endDate = endDateEl.value || undefined;
          if (progressEl && book.status === 'reading') book.progress = Number(progressEl.value);
          if (ratingEl) book.rating = Number(ratingEl.value);
          if (commentEl) book.comment = commentEl.value || null;
          if (descriptionEl) book.description = descriptionEl.value || undefined;
          if (favoriteEl) book.favorite = favoriteEl.checked;
          if (abandonedEl) book.abandoned = abandonedEl.checked;

          alert("Livre mis à jour !");
        }
      });
    });
    
    document.querySelectorAll<HTMLButtonElement>('.deleteBtn').forEach(btn => {
      btn.addEventListener('click', function(this: HTMLButtonElement) {
        if (!confirm("Voulez-vous vraiment supprimer ce livre ?")) return;
        const tr = this.closest('tr');
        if (!tr) return;
        
        const id = tr.getAttribute('data-id');
        booksData.books = booksData.books.filter(b => b.id !== id);
        renderBooks();
      });
    });
  }
  
  // Définir la fonction handleSubmit globalement
  window.handleSubmit = async (event: Event, book: GoogleBook) => {
    const formData = new FormData(event.target as HTMLFormElement);
    
    const newBook: Book = {
      id: crypto.randomUUID(),
      googleBooksId: book.id,
      status: formData.get('status') as Book['status'],
      progress: formData.get('status') === 'reading' ? Number(formData.get('progress')) : undefined,
      startDate: formData.get('startDate') as string || undefined,
      endDate: formData.get('endDate') as string || undefined,
      rating: formData.get('rating') ? Number(formData.get('rating')) : null,
      comment: formData.get('comment') as string || null,
      abandoned: formData.get('abandoned') === 'on',
      favorite: formData.get('favorite') === 'on',
      title: book.volumeInfo.title,
      authors: book.volumeInfo.authors || ['Auteur inconnu'],
      description: book.volumeInfo.description,
      imageUrl: book.volumeInfo.imageLinks?.thumbnail,
    };

    booksData.books.push(newBook);
    (event.target as HTMLFormElement).reset();
    renderBooks();
  };
  
  const downloadBtn = document.getElementById('downloadBtn');
  if (downloadBtn) {
    downloadBtn.addEventListener('click', function() {
      const dataStr = JSON.stringify(booksData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "books.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  }
  
  loadBooks();
</script> 